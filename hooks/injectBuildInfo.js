#!/usr/bin/env node

const fs = require("fs");
const path = require("path");
const { getConfigParser } = require("./utils");

/**
 * Táº¡o file JavaScript chá»©a build info vá»›i SQLite storage
 */
function createBuildInfoJS(buildInfo) {
  return `
// Auto-generated by cordova-plugin-change-app-info
// Build Time: ${buildInfo.buildTime}

(function() {
  'use strict';
  
  var newBuildInfo = ${JSON.stringify(buildInfo, null, 2)};
  var db = null;
  
  // Wait for deviceready
  document.addEventListener('deviceready', function() {
    initDatabase();
  }, false);
  
  /**
   * Khá»Ÿi táº¡o SQLite database
   */
  function initDatabase() {
    try {
      // Kiá»ƒm tra xem plugin cÃ³ Ä‘Æ°á»£c cÃ i Ä‘áº·t khÃ´ng
      if (!window.sqlitePlugin) {
        console.warn('[Build Info] SQLite plugin not found, falling back to localStorage');
        fallbackToLocalStorage();
        return;
      }
      
      // Má»Ÿ hoáº·c táº¡o database
      db = window.sqlitePlugin.openDatabase({
        name: 'app_build_info.db',
        location: 'default',
        androidDatabaseProvider: 'system'
      });
      
      console.log('[Build Info] SQLite database opened');
      
      // Táº¡o báº£ng náº¿u chÆ°a cÃ³
      createTables(function() {
        // Sau khi táº¡o báº£ng, lÆ°u build info
        saveBuildInfo();
      });
      
    } catch (e) {
      console.error('[Build Info] Failed to open database:', e);
      // Fallback to localStorage
      fallbackToLocalStorage();
    }
  }
  
  /**
   * Táº¡o cÃ¡c báº£ng cáº§n thiáº¿t
   */
  function createTables(callback) {
    db.transaction(function(tx) {
      // Báº£ng build_info: lÆ°u thÃ´ng tin build hiá»‡n táº¡i
      tx.executeSql(
        \`CREATE TABLE IF NOT EXISTS build_info (
          id INTEGER PRIMARY KEY,
          app_name TEXT,
          version_number TEXT,
          version_code TEXT,
          package_name TEXT,
          platform TEXT,
          build_time TEXT,
          build_timestamp INTEGER,
          api_hostname TEXT,
          api_base_url TEXT,
          environment TEXT,
          cdn_icon TEXT,
          updated_at TEXT
        )\`
      );
      
      // Báº£ng install_history: lÆ°u lá»‹ch sá»­ cÃ i Ä‘áº·t
      tx.executeSql(
        \`CREATE TABLE IF NOT EXISTS install_history (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          version_number TEXT,
          version_code TEXT,
          install_time TEXT,
          install_type TEXT,
          previous_version TEXT
        )\`
      );
      
      // Báº£ng user_data: lÆ°u dá»¯ liá»‡u user
      tx.executeSql(
        \`CREATE TABLE IF NOT EXISTS user_data (
          key TEXT PRIMARY KEY,
          value TEXT,
          updated_at TEXT
        )\`
      );
      
      // Báº£ng app_settings: lÆ°u settings
      tx.executeSql(
        \`CREATE TABLE IF NOT EXISTS app_settings (
          key TEXT PRIMARY KEY,
          value TEXT,
          updated_at TEXT
        )\`
      );
      
    }, function(error) {
      console.error('[Build Info] Failed to create tables:', error);
      fallbackToLocalStorage();
    }, function() {
      console.log('[Build Info] Tables created successfully');
      if (callback) callback();
    });
  }
  
  /**
   * LÆ°u build info vÃ o SQLite
   */
  function saveBuildInfo() {
    db.transaction(function(tx) {
      // Äá»c build info cÅ© Ä‘á»ƒ kiá»ƒm tra update
      tx.executeSql(
        'SELECT version_number, version_code FROM build_info WHERE id = 1',
        [],
        function(tx, result) {
          var isUpdate = false;
          var previousVersion = null;
          var previousVersionCode = null;
          var installType = 'first_install';
          
          if (result.rows.length > 0) {
            var oldInfo = result.rows.item(0);
            previousVersion = oldInfo.version_number;
            previousVersionCode = oldInfo.version_code;
            
            if (previousVersion !== newBuildInfo.versionNumber) {
              isUpdate = true;
              installType = 'update';
              console.log('[Build Info] Update detected:', previousVersion, 'â†’', newBuildInfo.versionNumber);
            } else {
              installType = 'reinstall';
            }
          }
          
          // LÆ°u vÃ o install history
          tx.executeSql(
            \`INSERT INTO install_history 
            (version_number, version_code, install_time, install_type, previous_version) 
            VALUES (?, ?, ?, ?, ?)\`,
            [
              newBuildInfo.versionNumber,
              newBuildInfo.versionCode,
              newBuildInfo.buildTime,
              installType,
              previousVersion
            ]
          );
          
          // Update hoáº·c insert build info
          tx.executeSql(
            \`INSERT OR REPLACE INTO build_info 
            (id, app_name, version_number, version_code, package_name, platform, 
             build_time, build_timestamp, api_hostname, api_base_url, environment, 
             cdn_icon, updated_at) 
            VALUES (1, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\`,
            [
              newBuildInfo.appName,
              newBuildInfo.versionNumber,
              newBuildInfo.versionCode,
              newBuildInfo.packageName,
              newBuildInfo.platform,
              newBuildInfo.buildTime,
              newBuildInfo.buildTimestamp,
              newBuildInfo.apiHostname,
              newBuildInfo.apiBaseUrl,
              newBuildInfo.environment,
              newBuildInfo.cdnIcon,
              new Date().toISOString()
            ]
          );
        }
      );
      
    }, function(error) {
      console.error('[Build Info] Failed to save:', error);
      fallbackToLocalStorage();
    }, function() {
      console.log('[Build Info] Build info saved successfully to SQLite');
      loadAndExposeBuildInfo();
    });
  }
  
  /**
   * Äá»c vÃ  expose build info ra window
   */
  function loadAndExposeBuildInfo() {
    db.transaction(function(tx) {
      // Äá»c build info
      tx.executeSql('SELECT * FROM build_info WHERE id = 1', [], function(tx, result) {
        if (result.rows.length > 0) {
          var buildInfo = result.rows.item(0);
          
          // Äá»c first install info
          tx.executeSql(
            'SELECT * FROM install_history ORDER BY id ASC LIMIT 1',
            [],
            function(tx, historyResult) {
              var firstInstall = historyResult.rows.length > 0 ? 
                                 historyResult.rows.item(0) : null;
              
              // Äá»c install count
              tx.executeSql(
                'SELECT COUNT(*) as count FROM install_history',
                [],
                function(tx, countResult) {
                  var installCount = countResult.rows.item(0).count;
                  
                  // Merge data
                  window.APP_BUILD_INFO = {
                    appName: buildInfo.app_name,
                    versionNumber: buildInfo.version_number,
                    versionCode: buildInfo.version_code,
                    packageName: buildInfo.package_name,
                    platform: buildInfo.platform,
                    buildTime: buildInfo.build_time,
                    buildTimestamp: buildInfo.build_timestamp,
                    apiHostname: buildInfo.api_hostname,
                    apiBaseUrl: buildInfo.api_base_url,
                    environment: buildInfo.environment,
                    cdnIcon: buildInfo.cdn_icon,
                    
                    // Install info
                    firstInstallTime: firstInstall ? firstInstall.install_time : buildInfo.build_time,
                    firstInstallVersion: firstInstall ? firstInstall.version_number : buildInfo.version_number,
                    installCount: installCount,
                    
                    // Storage type indicator
                    storageType: 'sqlite'
                  };
                  
                  console.log('[Build Info] Loaded from SQLite:', window.APP_BUILD_INFO);
                  console.log('[Build Info] API Hostname:', buildInfo.api_hostname);
                  console.log('[Build Info] First install:', window.APP_BUILD_INFO.firstInstallVersion, 
                             'at', window.APP_BUILD_INFO.firstInstallTime);
                  console.log('[Build Info] Install count:', installCount);
                  
                  // Trigger custom event khi data Ä‘Ã£ sáºµn sÃ ng
                  var event = new CustomEvent('buildInfoReady', { detail: window.APP_BUILD_INFO });
                  document.dispatchEvent(event);
                }
              );
            }
          );
        }
      });
    });
  }
  
  /**
   * Helper: Update user data
   */
  window.updateAppUserData = function(key, value, callback) {
    if (!db) {
      console.error('[Build Info] Database not initialized');
      if (callback) callback(new Error('Database not initialized'));
      return;
    }
    
    db.transaction(function(tx) {
      tx.executeSql(
        'INSERT OR REPLACE INTO user_data (key, value, updated_at) VALUES (?, ?, ?)',
        [key, JSON.stringify(value), new Date().toISOString()],
        function(tx, result) {
          console.log('[Build Info] User data updated:', key);
          if (callback) callback(null, result);
        },
        function(tx, error) {
          console.error('[Build Info] Failed to update user data:', error);
          if (callback) callback(error);
        }
      );
    });
  };
  
  /**
   * Helper: Get user data
   */
  window.getAppUserData = function(key, callback) {
    if (!db) {
      console.error('[Build Info] Database not initialized');
      if (callback) callback(new Error('Database not initialized'));
      return;
    }
    
    db.transaction(function(tx) {
      tx.executeSql(
        'SELECT value FROM user_data WHERE key = ?',
        [key],
        function(tx, result) {
          if (result.rows.length > 0) {
            try {
              var value = JSON.parse(result.rows.item(0).value);
              if (callback) callback(null, value);
            } catch (e) {
              if (callback) callback(e);
            }
          } else {
            if (callback) callback(null, null);
          }
        },
        function(tx, error) {
          if (callback) callback(error);
        }
      );
    });
  };
  
  /**
   * Helper: Get all user data
   */
  window.getAllAppUserData = function(callback) {
    if (!db) {
      console.error('[Build Info] Database not initialized');
      if (callback) callback(new Error('Database not initialized'));
      return;
    }
    
    db.transaction(function(tx) {
      tx.executeSql('SELECT key, value FROM user_data', [], function(tx, result) {
        var userData = {};
        for (var i = 0; i < result.rows.length; i++) {
          var row = result.rows.item(i);
          try {
            userData[row.key] = JSON.parse(row.value);
          } catch (e) {
            console.error('[Build Info] Failed to parse user data:', row.key, e);
          }
        }
        if (callback) callback(null, userData);
      }, function(tx, error) {
        if (callback) callback(error);
      });
    });
  };
  
  /**
   * Helper: Delete user data
   */
  window.deleteAppUserData = function(key, callback) {
    if (!db) {
      console.error('[Build Info] Database not initialized');
      if (callback) callback(new Error('Database not initialized'));
      return;
    }
    
    db.transaction(function(tx) {
      tx.executeSql(
        'DELETE FROM user_data WHERE key = ?',
        [key],
        function(tx, result) {
          console.log('[Build Info] User data deleted:', key);
          if (callback) callback(null, result);
        },
        function(tx, error) {
          console.error('[Build Info] Failed to delete user data:', error);
          if (callback) callback(error);
        }
      );
    });
  };
  
  /**
   * Helper: Update app settings
   */
  window.updateAppSettings = function(settings, callback) {
    if (!db) {
      console.error('[Build Info] Database not initialized');
      if (callback) callback(new Error('Database not initialized'));
      return;
    }
    
    db.transaction(function(tx) {
      var now = new Date().toISOString();
      Object.keys(settings).forEach(function(key) {
        tx.executeSql(
          'INSERT OR REPLACE INTO app_settings (key, value, updated_at) VALUES (?, ?, ?)',
          [key, JSON.stringify(settings[key]), now]
        );
      });
    }, function(error) {
      console.error('[Build Info] Failed to update settings:', error);
      if (callback) callback(error);
    }, function() {
      console.log('[Build Info] Settings updated');
      if (callback) callback(null);
    });
  };
  
  /**
   * Helper: Get single setting
   */
  window.getAppSetting = function(key, callback) {
    if (!db) {
      console.error('[Build Info] Database not initialized');
      if (callback) callback(new Error('Database not initialized'));
      return;
    }
    
    db.transaction(function(tx) {
      tx.executeSql(
        'SELECT value FROM app_settings WHERE key = ?',
        [key],
        function(tx, result) {
          if (result.rows.length > 0) {
            try {
              var value = JSON.parse(result.rows.item(0).value);
              if (callback) callback(null, value);
            } catch (e) {
              if (callback) callback(e);
            }
          } else {
            if (callback) callback(null, null);
          }
        },
        function(tx, error) {
          if (callback) callback(error);
        }
      );
    });
  };
  
  /**
   * Helper: Get all settings
   */
  window.getAppSettings = function(callback) {
    if (!db) {
      console.error('[Build Info] Database not initialized');
      if (callback) callback(new Error('Database not initialized'));
      return;
    }
    
    db.transaction(function(tx) {
      tx.executeSql('SELECT key, value FROM app_settings', [], function(tx, result) {
        var settings = {};
        for (var i = 0; i < result.rows.length; i++) {
          var row = result.rows.item(i);
          try {
            settings[row.key] = JSON.parse(row.value);
          } catch (e) {
            console.error('[Build Info] Failed to parse setting:', row.key, e);
          }
        }
        if (callback) callback(null, settings);
      }, function(tx, error) {
        if (callback) callback(error);
      });
    });
  };
  
  /**
   * Helper: Delete setting
   */
  window.deleteAppSetting = function(key, callback) {
    if (!db) {
      console.error('[Build Info] Database not initialized');
      if (callback) callback(new Error('Database not initialized'));
      return;
    }
    
    db.transaction(function(tx) {
      tx.executeSql(
        'DELETE FROM app_settings WHERE key = ?',
        [key],
        function(tx, result) {
          console.log('[Build Info] Setting deleted:', key);
          if (callback) callback(null, result);
        },
        function(tx, error) {
          console.error('[Build Info] Failed to delete setting:', error);
          if (callback) callback(error);
        }
      );
    });
  };
  
  /**
   * Helper: Get install history
   */
  window.getInstallHistory = function(callback) {
    if (!db) {
      console.error('[Build Info] Database not initialized');
      if (callback) callback(new Error('Database not initialized'));
      return;
    }
    
    db.transaction(function(tx) {
      tx.executeSql(
        'SELECT * FROM install_history ORDER BY id DESC',
        [],
        function(tx, result) {
          var history = [];
          for (var i = 0; i < result.rows.length; i++) {
            history.push(result.rows.item(i));
          }
          if (callback) callback(null, history);
        },
        function(tx, error) {
          if (callback) callback(error);
        }
      );
    });
  };
  
  /**
   * Helper: Clear all data (for testing/reset)
   */
  window.clearAppBuildData = function(callback) {
    if (!db) {
      console.error('[Build Info] Database not initialized');
      if (callback) callback(new Error('Database not initialized'));
      return;
    }
    
    db.transaction(function(tx) {
      tx.executeSql('DELETE FROM user_data');
      tx.executeSql('DELETE FROM app_settings');
      // Note: KhÃ´ng xÃ³a build_info vÃ  install_history Ä‘á»ƒ giá»¯ lá»‹ch sá»­
    }, function(error) {
      console.error('[Build Info] Failed to clear data:', error);
      if (callback) callback(error);
    }, function() {
      console.log('[Build Info] User data and settings cleared');
      if (callback) callback(null);
    });
  };
  
  /**
   * Fallback to localStorage if SQLite fails
   */
  function fallbackToLocalStorage() {
    try {
      var existingDataStr = localStorage.getItem('APP_BUILD_INFO');
      var existingData = existingDataStr ? JSON.parse(existingDataStr) : {};
      
      var preservedData = {
        firstInstallTime: existingData.firstInstallTime || newBuildInfo.buildTime,
        firstInstallVersion: existingData.firstInstallVersion || newBuildInfo.versionNumber,
        installCount: (existingData.installCount || 0) + 1,
        userData: existingData.userData || {},
        userSettings: existingData.userSettings || {},
        lastActiveTime: existingData.lastActiveTime || null
      };
      
      var isUpdate = existingData.versionNumber && 
                     existingData.versionNumber !== newBuildInfo.versionNumber;
      
      if (isUpdate) {
        preservedData.lastUpdateTime = new Date().toISOString();
        preservedData.previousVersion = existingData.versionNumber;
        preservedData.previousVersionCode = existingData.versionCode;
        console.log('[Build Info] Update detected:', existingData.versionNumber, 'â†’', newBuildInfo.versionNumber);
      }
      
      var mergedBuildInfo = Object.assign({}, newBuildInfo, preservedData, { storageType: 'localStorage' });
      localStorage.setItem('APP_BUILD_INFO', JSON.stringify(mergedBuildInfo));
      window.APP_BUILD_INFO = mergedBuildInfo;
      
      console.log('[Build Info] Saved to localStorage (fallback)');
      console.log('[Build Info] API Hostname:', mergedBuildInfo.apiHostname);
      console.log('[Build Info] First install:', preservedData.firstInstallVersion, 'at', preservedData.firstInstallTime);
      console.log('[Build Info] Install count:', preservedData.installCount);
      
      // Trigger custom event
      var event = new CustomEvent('buildInfoReady', { detail: window.APP_BUILD_INFO });
      document.dispatchEvent(event);
      
      // Override helpers Ä‘á»ƒ dÃ¹ng localStorage
      window.updateAppUserData = function(key, value) {
        try {
          var buildInfo = JSON.parse(localStorage.getItem('APP_BUILD_INFO') || '{}');
          if (!buildInfo.userData) buildInfo.userData = {};
          buildInfo.userData[key] = value;
          buildInfo.lastActiveTime = new Date().toISOString();
          localStorage.setItem('APP_BUILD_INFO', JSON.stringify(buildInfo));
          window.APP_BUILD_INFO = buildInfo;
          console.log('[Build Info] User data updated (localStorage):', key);
        } catch (e) {
          console.error('[Build Info] Failed to update user data:', e);
        }
      };
      
      window.updateAppSettings = function(settings) {
        try {
          var buildInfo = JSON.parse(localStorage.getItem('APP_BUILD_INFO') || '{}');
          buildInfo.userSettings = Object.assign(buildInfo.userSettings || {}, settings);
          buildInfo.lastActiveTime = new Date().toISOString();
          localStorage.setItem('APP_BUILD_INFO', JSON.stringify(buildInfo));
          window.APP_BUILD_INFO = buildInfo;
          console.log('[Build Info] Settings updated (localStorage)');
        } catch (e) {
          console.error('[Build Info] Failed to update settings:', e);
        }
      };
      
    } catch (e) {
      console.error('[Build Info] Fallback also failed:', e);
    }
  }
  
})();
`;
}

/**
 * Inject build info vÃ o www folder
 */
function injectBuildInfo(context, platform) {
  const root = context.opts.projectRoot;
  
  // Äá»c config
  const config = getConfigParser(context, path.join(root, "config.xml"));
  
  // Äá»c hostname tá»« config
  const apiHostname = config.getPreference("API_HOSTNAME") || "";
  const apiBaseUrl = config.getPreference("API_BASE_URL") || "";
  const environment = config.getPreference("ENVIRONMENT") || "production";
  
  const buildInfo = {
    // Build info (sáº½ Ä‘Æ°á»£c update má»—i build)
    appName: config.getPreference("APP_NAME") || config.name() || "Unknown",
    versionNumber: config.getPreference("VERSION_NUMBER") || config.version() || "0.0.0",
    versionCode: config.getPreference("VERSION_CODE") || "0",
    packageName: config.packageName() || "unknown",
    platform: platform,
    buildTime: new Date().toISOString(),
    buildTimestamp: Date.now(),
    
    // API Configuration (cÃ³ thá»ƒ thay Ä‘á»•i theo environment)
    apiHostname: apiHostname,
    apiBaseUrl: apiBaseUrl,
    environment: environment,
    
    // CDN Info (optional)
    cdnIcon: config.getPreference("CDN_ICON") || null
    
    // firstInstallTime, firstInstallVersion, userData, userSettings
    // sáº½ Ä‘Æ°á»£c preserve tá»« SQLite hoáº·c localStorage cÅ©
  };
  
  // ÄÆ°á»ng dáº«n www cá»§a platform
  let wwwPath;
  if (platform === "android") {
    wwwPath = path.join(root, "platforms/android/app/src/main/assets/www");
  } else if (platform === "ios") {
    wwwPath = path.join(root, "platforms/ios/www");
  } else {
    console.log(`âš ï¸ Platform ${platform} not supported for build info injection`);
    return;
  }
  
  if (!fs.existsSync(wwwPath)) {
    console.log(`âš ï¸ WWW path not found: ${wwwPath}`);
    return;
  }
  
  // Táº¡o file build-info.js
  const buildInfoPath = path.join(wwwPath, "build-info.js");
  const jsContent = createBuildInfoJS(buildInfo);
  
  fs.writeFileSync(buildInfoPath, jsContent, "utf8");
  console.log(`âœ… Build info injected to: ${buildInfoPath}`);
  console.log(`   App: ${buildInfo.appName} v${buildInfo.versionNumber} (${buildInfo.versionCode})`);
  console.log(`   Environment: ${buildInfo.environment}`);
  console.log(`   API Hostname: ${buildInfo.apiHostname || 'Not configured'}`);
  console.log(`   API Base URL: ${buildInfo.apiBaseUrl || 'Not configured'}`);
  console.log(`   Build: ${buildInfo.buildTime}`);
  console.log(`   Storage: SQLite with localStorage fallback`);
  console.log(`   Note: User data and install history will be preserved in SQLite`);
  
  // ThÃªm script tag vÃ o index.html
  injectScriptTag(wwwPath, "build-info.js");
}

/**
 * ThÃªm <script> tag vÃ o index.html
 */
function injectScriptTag(wwwPath, scriptFile) {
  const indexPath = path.join(wwwPath, "index.html");
  
  if (!fs.existsSync(indexPath)) {
    console.log("âš ï¸ index.html not found");
    return;
  }
  
  let html = fs.readFileSync(indexPath, "utf8");
  
  // Check xem Ä‘Ã£ cÃ³ script tag chÆ°a
  if (html.includes(scriptFile)) {
    console.log("   Script tag already exists in index.html");
    return;
  }
  
  // ThÃªm script tag trÆ°á»›c </head> hoáº·c trÆ°á»›c cordova.js
  const scriptTag = `    <script src="${scriptFile}"></script>`;
  
  // Æ¯u tiÃªn thÃªm trÆ°á»›c cordova.js
  if (html.includes('cordova.js')) {
    html = html.replace(
      /<script[^>]*src=["']cordova\.js["'][^>]*><\/script>/,
      `${scriptTag}\n    $&`
    );
  } else if (html.includes("</head>")) {
    html = html.replace("</head>", `${scriptTag}\n  </head>`);
  } else if (html.includes("</body>")) {
    html = html.replace("</body>", `${scriptTag}\n  </body>`);
  } else {
    console.log("âš ï¸ Could not find suitable location in index.html");
    return;
  }
  
  fs.writeFileSync(indexPath, html, "utf8");
  console.log(`   Added <script> tag to index.html`);
}

/**
 * Hook chÃ­nh
 */
module.exports = function(context) {
  const platforms = context.opts.platforms;
  
  console.log("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  console.log("  INJECT BUILD INFO HOOK (SQLite) ");
  console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  
  for (const platform of platforms) {
    console.log(`\nğŸ“± Processing ${platform}...`);
    injectBuildInfo(context, platform);
  }
  
  console.log("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  console.log("âœ… Build info injection completed!");
  console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
};
